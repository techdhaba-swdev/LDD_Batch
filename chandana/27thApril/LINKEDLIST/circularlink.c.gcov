        -:    0:Source:circularlink.c
        -:    1:#include "clink.h"      // Include the header file that contains the structure definition and function prototypes
        -:    2:#include <stdio.h>      // Include standard I/O functions
        -:    3:#include <stdlib.h>     // Include standard library functions for memory allocation
        -:    4:
        -:    5:// Create a new node with the given data
function createNode called 5 returned 100% blocks executed 60%
        5:    6:struct Node* createNode(int data) {
        -:    7:    // Allocate memory for the new node
        5:    8:    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        -:    9:    // Check if memory allocation was successful
        5:   10:    if (newNode == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   11:        printf("Memory allocation failed\n");  // Print an error message
call    0 never executed
    #####:   12:        exit(EXIT_FAILURE);  // Exit the program
call    0 never executed
        -:   13:    }
        -:   14:    // Assign the data to the new node
        5:   15:    newNode->data = data;
        -:   16:    // Set the next pointer to NULL (not yet connected to any other node)
        5:   17:    newNode->next = NULL;
        -:   18:    // Return a pointer to the new node
        5:   19:    return newNode;
        -:   20:}
        -:   21:
        -:   22:// Add a new node with the given data to the end of the list
function addNode called 5 returned 100% blocks executed 100%
        5:   23:void addNode(struct Node** head, int data) {
        -:   24:    // Create a new node with the given data
        5:   25:    struct Node* newNode = createNode(data);
call    0 returned 100%
        -:   26:    // Check if the list is empty
        5:   27:    if (*head == NULL) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:   28:        // If so, make the new node the head of the list
        1:   29:        *head = newNode;
        -:   30:        // Point the new node to itself to create a circular list
        1:   31:        newNode->next = *head;
        -:   32:    } else {
        -:   33:        // If the list is not empty, traverse to the last node
        4:   34:        struct Node* temp = *head;
       10:   35:        while (temp->next != *head) {
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        6:   36:            temp = temp->next;
        -:   37:        }
        -:   38:        // Connect the last node to the new node
        4:   39:        temp->next = newNode;
        -:   40:        // Point the new node back to the head to maintain circularity
        4:   41:        newNode->next = *head;
        -:   42:    }
        5:   43:}
        -:   44:
        -:   45:// Calculate the sum of all node values in the list
function calculateSum called 1 returned 100% blocks executed 83%
        1:   46:int calculateSum(struct Node* head) {
        -:   47:    // Initialize the sum to 0
        1:   48:    int sum = 0;
        -:   49:    // Check if the list is empty
        1:   50:    if (head == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   51:        return sum;
        -:   52:    }
        -:   53:    // Create a pointer to traverse the list
        1:   54:    struct Node* current = head;
        -:   55:    // Traverse the list and add each node's data to the sum
        -:   56:    do {
        5:   57:        sum += current->data;
        5:   58:        current = current->next;
        5:   59:    } while (current != head);  // Continue until we reach the head again
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   60:    // Return the sum
        1:   61:    return sum;
        -:   62:}
        -:   63:
        -:   64:// Print all node values in the list
function printList called 1 returned 100% blocks executed 86%
        1:   65:void printList(struct Node* head) {
        -:   66:    // Check if the list is empty
        1:   67:    if (head == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   68:        return;
        -:   69:    }
        -:   70:    // Create a pointer to traverse the list
        1:   71:    struct Node* current = head;
        -:   72:    // Traverse the list and print each node's data
        -:   73:    do {
        5:   74:        printf("%d ", current->data);
call    0 returned 100%
        5:   75:        current = current->next;
        5:   76:    } while (current != head);  // Continue until we reach the head again
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   77:    // Print a newline character to end the line
        1:   78:    printf("\n");
call    0 returned 100%
        -:   79:}
        -:   80:
        -:   81:// Free all memory allocated for the list
function freeList called 1 returned 100% blocks executed 83%
        1:   82:void freeList(struct Node** head) {
        -:   83:    // Check if the list is empty
        1:   84:    if (*head == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   85:        return;
        -:   86:    }
        -:   87:    // Create a pointer to traverse the list
        1:   88:    struct Node* current = *head;
        -:   89:    // Create a temporary pointer to hold the next node to be freed
        -:   90:    struct Node* temp;
        -:   91:    // Traverse the list and free each node
        -:   92:    do {
        5:   93:        temp = current;
        5:   94:        current = current->next;
        5:   95:        free(temp);
        5:   96:    } while (current != *head);  // Continue until we reach the head again
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:   97:    // Set the head pointer to NULL to indicate that the list is empty
        1:   98:    *head = NULL;
        -:   99:}
