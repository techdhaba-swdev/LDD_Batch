        -:    0:Source:queue.c
        -:    1:#include "queue.h"    // Include the header file that contains the structure definition and function prototypes
        -:    2:
        -:    3:// Initialize the queue
function initializeQueue called 1 returned 100% blocks executed 100%
        1:    4:void initializeQueue(Queue *queue) {
        1:    5:    queue->front = -1;  // Initialize front index to -1 (empty queue)
        1:    6:    queue->rear = -1;   // Initialize rear index to -1 (empty queue)
        1:    7:}
        -:    8:
        -:    9:// Check if the queue is full
function isFull called 3 returned 100% blocks executed 71%
        3:   10:bool isFull(Queue *queue) {
        -:   11:    // Queue is full if front is 0 and rear is at the end, or if rear is just before front
       3*:   12:    return (queue->rear == MAX_SIZE - 1 && queue->front == 0) || (queue->rear == queue->front - 1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:   13:}
        -:   14:
        -:   15:// Check if the queue is empty
function isEmpty called 6 returned 100% blocks executed 100%
        6:   16:bool isEmpty(Queue *queue) {
        -:   17:    // Queue is empty if front index is -1
        6:   18:    return queue->front == -1;
        -:   19:}
        -:   20:
        -:   21:// Enqueue an element into the queue
function enqueue called 3 returned 100% blocks executed 78%
        3:   22:void enqueue(Queue *queue, int value) {
        3:   23:    if (isFull(queue)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   24:        printf("Queue Overflow\n");  // Print an error message if queue is full
call    0 never executed
    #####:   25:        return;
        -:   26:    }
        3:   27:    if (isEmpty(queue)) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1:   28:        queue->front = 0;  // If queue is empty, set front to 0
        -:   29:    }
        3:   30:    queue->rear = (queue->rear + 1) % MAX_SIZE;  // Circular increment of rear index
        3:   31:    queue->items[queue->rear] = value;  // Add value to the rear of the queue
        -:   32:}
        -:   33:
        -:   34:// Dequeue an element from the queue
function dequeue called 1 returned 100% blocks executed 67%
        1:   35:int dequeue(Queue *queue) {
        1:   36:    if (isEmpty(queue)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   37:        printf("Queue Underflow\n");  // Print an error message if queue is empty
call    0 never executed
    #####:   38:        return -1;
        -:   39:    }
        1:   40:    int value = queue->items[queue->front];  // Get the front element
        1:   41:    if (queue->front == queue->rear) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   42:        // Reset front and rear to -1 if this is the last element in the queue
    #####:   43:        queue->front = -1;
    #####:   44:        queue->rear = -1;
        -:   45:    } else {
        -:   46:        // Circular increment of front index
        1:   47:        queue->front = (queue->front + 1) % MAX_SIZE;
        -:   48:    }
        1:   49:    return value;  // Return the dequeued value
        -:   50:}
        -:   51:
        -:   52:// Display the queue elements
function displayQueue called 2 returned 100% blocks executed 82%
        2:   53:void displayQueue(Queue *queue) {
        2:   54:    if (isEmpty(queue)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   55:        printf("Queue is empty\n");  // Print an error message if queue is empty
call    0 never executed
    #####:   56:        return;
        -:   57:    }
        2:   58:    printf("Queue: ");
call    0 returned 100%
        2:   59:    int i = queue->front;
        5:   60:    while (i != queue->rear) {
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        3:   61:        printf("%d ", queue->items[i]);  // Print each element from front to rear
call    0 returned 100%
        3:   62:        i = (i + 1) % MAX_SIZE;  // Circular increment of index
        -:   63:    }
        2:   64:    printf("%d\n", queue->items[i]);  // Print the last element
call    0 returned 100%
        -:   65:}
