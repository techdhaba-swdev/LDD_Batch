        -:    0:Source:bst.c
        -:    1:#include "bst.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:
        -:    5:// Function to create a new node
function createNode called 7 returned 100% blocks executed 60%
        7:    6:struct node* createNode(int data) {
        7:    7:    struct node* newNode = (struct node*)malloc(sizeof(struct node));
        7:    8:    if (newNode == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:    9:        fprintf(stderr, "Memory allocation failed\n");
call    0 never executed
    #####:   10:        exit(EXIT_FAILURE);
call    0 never executed
        -:   11:    }
        7:   12:    newNode->data = data;
        7:   13:    newNode->left = NULL;
        7:   14:    newNode->right = NULL;
        7:   15:    return newNode;
        -:   16:}
        -:   17:
        -:   18:// Function to insert a new node into the BST
function insert called 17 returned 100% blocks executed 100%
       17:   19:struct node* insert(struct node* root, int data) {
       17:   20:    if (root == NULL) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        7:   21:        return createNode(data);
call    0 returned 100%
        -:   22:    }
       10:   23:    if (data < root->data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:   24:        root->left = insert(root->left, data);
call    0 returned 100%
        5:   25:    } else if (data > root->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:   26:        root->right = insert(root->right, data);
call    0 returned 100%
        -:   27:    }
       10:   28:    return root;
        -:   29:}
        -:   30:
        -:   31:// Function to search for a node with the given data
function search called 3 returned 100% blocks executed 90%
        3:   32:int search(struct node* root, int data) {
        3:   33:    if (root == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   34:        return 0;
        -:   35:    }
        3:   36:    if (root->data == data) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:   37:        return 1;
        2:   38:    } else if (data < root->data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:   39:        return search(root->left, data);
call    0 returned 100%
        -:   40:    } else {
        1:   41:        return search(root->right, data);
call    0 returned 100%
        -:   42:    }
        -:   43:}
        -:   44:
        -:   45:// Function to perform in-order traversal
function inorderTraversal called 15 returned 100% blocks executed 100%
       15:   46:void inorderTraversal(struct node* root) {
       15:   47:    if (root != NULL) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7:   48:        inorderTraversal(root->left);
call    0 returned 100%
        7:   49:        printf("%d ", root->data);
call    0 returned 100%
        7:   50:        inorderTraversal(root->right);
call    0 returned 100%
        -:   51:    }
       15:   52:}
