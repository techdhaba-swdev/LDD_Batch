        -:    0:Source:queue.c
        -:    1:#include "queue.h" // Include the header file for the queue
        -:    2:
        -:    3:#include <stdio.h> // Include standard input/output functions
        -:    4:#include <stdlib.h> // Include standard library functions
        -:    5:
        -:    6:#define MAX_SIZE 100 // Define the maximum size of the queue
        -:    7:
        -:    8:// Define the structure for the queue
        -:    9:struct Queue {
        -:   10:    int items[MAX_SIZE]; // Array to store queue elements
        -:   11:    int front; // Index of the front element
        -:   12:    int rear; // Index of the rear element
        -:   13:};
        -:   14:
        -:   15:// Function to create a new queue
function createQueue called 1 returned 100% blocks executed 100%
        1:   16:Queue* createQueue() {
        1:   17:    Queue* queue = (Queue*)malloc(sizeof(Queue)); // Allocate memory for the queue structure
        1:   18:    queue->front = -1; // Initialize front index
        1:   19:    queue->rear = -1; // Initialize rear index
        1:   20:    return queue; // Return the newly created queue
        -:   21:}
        -:   22:
        -:   23:// Function to check if the queue is empty
function isEmpty called 2 returned 100% blocks executed 75%
        2:   24:int isEmpty(Queue* queue) {
        2:   25:    if (queue->rear == -1) // If rear index is -1, the queue is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   26:        return 1;
        -:   27:    else
        2:   28:        return 0;
        -:   29:}
        -:   30:
        -:   31:// Function to check if the queue is full
function isFull called 4 returned 100% blocks executed 75%
        4:   32:int isFull(Queue* queue) {
        4:   33:    if (queue->rear == MAX_SIZE - 1) // If rear index is equal to the maximum size minus 1, the queue is full
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   34:        return 1;
        -:   35:    else
        4:   36:        return 0;
        -:   37:}
        -:   38:
        -:   39:// Function to enqueue an element into the queue
function enqueue called 4 returned 100% blocks executed 86%
        4:   40:void enqueue(Queue* queue, int value) {
        4:   41:    if (isFull(queue)) { // Check if the queue is full
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   42:        printf("Queue is full!\n"); // Print an error message if the queue is full
call    0 never executed
        -:   43:    } else {
        4:   44:        if (queue->front == -1) // If the front index is -1, set it to 0
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1:   45:            queue->front = 0;
        4:   46:        queue->rear++; // Increment the rear index
        4:   47:        queue->items[queue->rear] = value; // Insert the value at the rear index
        4:   48:        printf("%d enqueued to queue.\n", value); // Print a message indicating successful enqueue operation
call    0 returned 100%
        -:   49:    }
        4:   50:}
        -:   51:
        -:   52:// Function to dequeue an element from the queue
function dequeue called 2 returned 100% blocks executed 62%
        2:   53:int dequeue(Queue* queue) {
        -:   54:    int item; // Variable to store the dequeued item
        2:   55:    if (isEmpty(queue)) { // Check if the queue is empty
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   56:        printf("Queue is empty!\n"); // Print an error message if the queue is empty
call    0 never executed
    #####:   57:        return -1; // Return -1 to indicate failure
        -:   58:    } else {
        2:   59:        item = queue->items[queue->front]; // Get the item at the front index
        2:   60:        queue->front++; // Increment the front index
        2:   61:        if (queue->front > queue->rear) { // If front index surpasses rear index, reset indices
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   62:            queue->front = queue->rear = -1;
        -:   63:        }
        2:   64:        return item; // Return the dequeued item
        -:   65:    }
        -:   66:}
