        -:    0:Source:bst.c
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include "bst.h"
        -:    4:
        -:    5:// Structure definition for a node in the Binary Search Tree (BST)
        -:    6:struct node {
        -:    7:    int data;
        -:    8:    struct node* left;
        -:    9:    struct node* right;
        -:   10:};
        -:   11:
        -:   12:// Function to create a new node with the given data
function createNode called 7 returned 100% blocks executed 60%
        7:   13:struct node* createNode(int data) {
        -:   14:    // Allocate memory for the new node
        7:   15:    struct node* newNode = (struct node*)malloc(sizeof(struct node));
        -:   16:    
        -:   17:    // Check if memory allocation was successful
        7:   18:    if (newNode == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   19:        printf("Memory allocation failed.\n");
call    0 never executed
    #####:   20:        exit(1);
call    0 never executed
        -:   21:    }
        -:   22:    
        -:   23:    // Initialize the node's data and child pointers
        7:   24:    newNode->data = data;
        7:   25:    newNode->left = NULL;
        7:   26:    newNode->right = NULL;
        -:   27:    
        -:   28:    // Return the newly created node
        7:   29:    return newNode;
        -:   30:}
        -:   31:
        -:   32:// Function to insert a new node with the given data into the BST
function insert called 17 returned 100% blocks executed 100%
       17:   33:struct node* insert(struct node* root, int data) {
        -:   34:    // If the tree is empty, create a new node and return it as the root
       17:   35:    if (root == NULL) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        7:   36:        return createNode(data);
call    0 returned 100%
        -:   37:    }
        -:   38:
        -:   39:    //Insert the data into the appropriate subtree
       10:   40:    if (data < root->data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:   41:        root->left = insert(root->left, data);
call    0 returned 100%
        5:   42:    } else if (data > root->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:   43:        root->right = insert(root->right, data);
call    0 returned 100%
        -:   44:    }
        -:   45:
        -:   46:    // Return the root of the modified tree
       10:   47:    return root;
        -:   48:}
        -:   49:
        -:   50:// Function to search for a node with the given data in the BST
function search called 7 returned 100% blocks executed 100%
        7:   51:int search(struct node* root, int data) {
        -:   52:    // If the tree is empty or the data is not found, return 0
        7:   53:    if (root == NULL) {
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        1:   54:        return 0;
        -:   55:    }
        -:   56:
        -:   57:    // If the data is found, return 1
        6:   58:    if (root->data == data) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:   59:        return 1;
        -:   60:    }
        -:   61:    
        -:   62:    // Search in the left subtree if the data is less than the current node's data
        -:   63:    // or in the right subtree if the data is greater than the current node's data
        5:   64:    else if (data < root->data) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        1:   65:        return search(root->left, data);
call    0 returned 100%
        -:   66:    } else {
        4:   67:        return search(root->right, data);
call    0 returned 100%
        -:   68:    }
        -:   69:}
        -:   70:
        -:   71:// Function to perform an in-order traversal of the BST
function inorderTraversal called 15 returned 100% blocks executed 100%
       15:   72:void inorderTraversal(struct node* root) {
        -:   73:    //If the current node is NULL, return
       15:   74:    if (root == NULL) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        8:   75:        return;
        -:   76:    }
        -:   77:
        -:   78:    // Traverse the left subtree, visit the current node, and then traverse the right subtree
        7:   79:    inorderTraversal(root->left);
call    0 returned 100%
        7:   80:    printf("%d ", root->data);
call    0 returned 100%
        7:   81:    inorderTraversal(root->right);
call    0 returned 100%
        -:   82:}
        -:   83:
        -:   84:// Function to deallocate memory for the entire BST
function destroyTree called 15 returned 100% blocks executed 100%
       15:   85:void destroyTree(struct node* root) {
        -:   86:    // Base case: If the current node is NULL, return
       15:   87:    if (root == NULL) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        8:   88:        return;
        -:   89:    }
        -:   90:
        -:   91:    //Deallocate memory for the left subtree, right subtree, and then the current node
        7:   92:    destroyTree(root->left);
call    0 returned 100%
        7:   93:    destroyTree(root->right);
call    0 returned 100%
        7:   94:    free(root);
        -:   95:}
