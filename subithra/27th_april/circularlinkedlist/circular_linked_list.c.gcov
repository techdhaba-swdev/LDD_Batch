        -:    0:Source:circular_linked_list.c
        -:    1:#include "circular_linked_list.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:
        -:    5:// Define the Node structure
        -:    6:struct Node {
        -:    7:    int data;
        -:    8:    struct Node *next;
        -:    9:};
        -:   10:
        -:   11:// Function to create a new node
function createNode called 4 returned 100% blocks executed 60%
        4:   12:Node* createNode(int data) {
        4:   13:    Node *newNode = malloc(sizeof(Node)); // Allocate memory for the new node
        4:   14:    if (newNode == NULL) { // Check if memory allocation failed
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   15:        perror("Memory allocation failed");
call    0 never executed
    #####:   16:        exit(EXIT_FAILURE);
call    0 never executed
        -:   17:    }
        4:   18:    newNode->data = data; // Assign data to the new node
        4:   19:    newNode->next = NULL; // Set next pointer to NULL
        4:   20:    return newNode; // Return the new node
        -:   21:}
        -:   22:
        -:   23:// Function to insert a node at the beginning of the list
function insertAtBeginning called 1 returned 100% blocks executed 73%
        1:   24:void insertAtBeginning(Node **head, int data) {
        1:   25:    if (head == NULL) { // Check if head pointer is NULL
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   26:        fprintf(stderr, "Invalid parameter: head is NULL\n");
call    0 never executed
    #####:   27:        return;
        -:   28:    }
        1:   29:    Node *newNode = createNode(data); // Create a new node
call    0 returned 100%
        1:   30:    if (*head == NULL) { // Check if the list is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   31:        *head = newNode; // Set the new node as the head
    #####:   32:        (*head)->next = *head; // Make the new node point to itself
        -:   33:    } else {
        1:   34:        Node *last = *head; // Find the last node in the list
        3:   35:        while (last->next != *head) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:   36:            last = last->next;
        -:   37:        }
        1:   38:        newNode->next = *head; // Set the next pointer of the new node to the current head
        1:   39:        last->next = newNode; // Make the last node point to the new node
        1:   40:        *head = newNode; // Set the new node as the head
        -:   41:    }
        -:   42:}
        -:   43:
        -:   44:// Function to display the circular linked list
function displayList called 2 returned 100% blocks executed 75%
        2:   45:void displayList(Node *head) {
        2:   46:    if (head == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   47:        printf("List is empty\n");
call    0 never executed
    #####:   48:        return;
        -:   49:    }
        2:   50:    Node *temp = head; // Create a temporary pointer to traverse the list
        -:   51:    do { // Traverse the list
        7:   52:        printf("%d ", temp->data); // Print the data of the current node
call    0 returned 100%
        7:   53:        temp = temp->next; // Move to the next node
        7:   54:    } while (temp != head); // Continue until we reach the head node again
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        2:   55:    printf("\n");
call    0 returned 100%
        -:   56:}
        -:   57:
        -:   58:// Function to insert a node at the end of the list
function insertAtEnd called 3 returned 100% blocks executed 82%
        3:   59:void insertAtEnd(Node **head, int data) {
        3:   60:    if (head == NULL) { // Check if head pointer is NULL
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   61:        fprintf(stderr, "Invalid parameter: head is NULL\n");
call    0 never executed
    #####:   62:        return;
        -:   63:    }
        3:   64:    Node *newNode = createNode(data); // Create a new node
call    0 returned 100%
        3:   65:    if (*head == NULL) { // Check if the list is empty
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:   66:        *head = newNode; // Set the new node as the head
        1:   67:        (*head)->next = *head; // Make the new node point to itself
        -:   68:    } else {
        2:   69:        Node *last = *head; // Find the last node in the list
        3:   70:        while (last->next != *head) {
branch  0 taken 33%
branch  1 taken 67% (fallthrough)
        1:   71:            last = last->next;
        -:   72:        }
        2:   73:        last->next = newNode; // Make the last node point to the new node
        2:   74:        newNode->next = *head; // Make the new node point to the head
        -:   75:    }
        -:   76:}
        -:   77:
        -:   78:// Function to delete a node from the list
function deleteNode called 1 returned 100% blocks executed 50%
        1:   79:void deleteNode(Node **head, int key) {
        1:   80:    if (head == NULL || *head == NULL) { // Check if head pointer is NULL or list is empty
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   81:        fprintf(stderr, "Invalid parameter: head is NULL or list is empty\n");
call    0 never executed
    #####:   82:        return;
        -:   83:    }
        1:   84:    Node *temp = *head; // Create a temporary pointer to traverse the list
        1:   85:    Node *prev = NULL; // Create a pointer to store the previous node
        3:   86:    while (temp->data != key) { // Find the node to be deleted
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:   87:        prev = temp; // Store the previous node
        2:   88:        temp = temp->next; // Move to the next node
        2:   89:        if (temp == *head) { // Check if we have traversed the entire list
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   90:            printf("Node with data %d not found in the list.\n", key);
call    0 never executed
    #####:   91:            return;
        -:   92:        }
        -:   93:    }
        1:   94:    if (temp == *head) { // Check if the node to be deleted is the head node
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   95:        prev = *head;
    #####:   96:        while (prev->next != *head) {
branch  0 never executed
branch  1 never executed
    #####:   97:            prev = prev->next;
        -:   98:        }
    #####:   99:        *head = temp->next; // Update the head pointer
    #####:  100:        prev->next = *head; // Update the next pointer of the last node
    #####:  101:        free(temp); // Free memory for the deleted node
        -:  102:    } else {
        1:  103:        prev->next = temp->next; // Update the next pointer of the previous node
        1:  104:        free(temp); // Free memory for the deleted node
        -:  105:    }
        -:  106:}
        -:  107:
        -:  108:// Function to free the memory allocated to the list
function freeList called 1 returned 100% blocks executed 75%
        1:  109:void freeList(Node **head) {
        1:  110:    if (head == NULL || *head == NULL) { // Check if head pointer is NULL or list is empty
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  111:        fprintf(stderr, "Invalid parameter: head is NULL or list is empty\n");
call    0 never executed
    #####:  112:        return;
        -:  113:    }
        1:  114:    Node *current = *head; // Create a pointer to traverse the list
        -:  115:    Node *next; // Create a pointer to store the next node
        -:  116:    do { // Traverse the list
        3:  117:        next = current->next; // Store the next node
        3:  118:        free(current); // Free memory for the current node
        3:  119:        current = next; // Move to the next node
        3:  120:    } while (current != *head); // Continue until we reach the head node again
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        1:  121:    *head = NULL; // Set the head pointer to NULL
        -:  122:}
