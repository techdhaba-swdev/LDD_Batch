        -:    0:Source:bst_tree.c
        -:    1:#include <stdio.h> // Standard input-output header
        -:    2:#include <stdlib.h> // Standard library header
        -:    3:#include <limits.h> // Header for limits of integral types
        -:    4:#include "bst_tree.h" // Header file for BST operations
        -:    5:
        -:    6:// Structure representing a node in the binary search tree
        -:    7:struct Node {
        -:    8:    int data; // Data stored in the node
        -:    9:    struct Node *left; // Pointer to the left child node
        -:   10:    struct Node *right; // Pointer to the right child node
        -:   11:};
        -:   12:
        -:   13:// Function to create a new node with the given data
        -:   14:// Used to secure: Memory allocation (malloc) is checked for errors
function createNode called 0 returned 0% blocks executed 0%
    #####:   15:struct Node* createNode(int data) {
    #####:   16:    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); // Allocate memory for the new node
    #####:   17:    if (newNode == NULL) { // Check if memory allocation was successful
branch  0 never executed
branch  1 never executed
    #####:   18:        printf("Memory allocation error.\n"); // Print error message
call    0 never executed
    #####:   19:        exit(EXIT_FAILURE); // Exit the program with failure status
call    0 never executed
        -:   20:    }
    #####:   21:    newNode->data = data; // Assign data to the new node
    #####:   22:    newNode->left = NULL; // Initialize left child as NULL
    #####:   23:    newNode->right = NULL; // Initialize right child as NULL
    #####:   24:    return newNode; // Return the pointer to the new node
        -:   25:}
        -:   26:
        -:   27:// Function to insert a value into the binary search tree
        -:   28:// Used to secure: Proper insertion into the binary search tree
function insert called 0 returned 0% blocks executed 0%
    #####:   29:struct Node* insert(struct Node* root, int data) {
    #####:   30:    if (root == NULL) { // If the tree is empty
branch  0 never executed
branch  1 never executed
    #####:   31:        return createNode(data); // Create a new node and return it as the root
call    0 never executed
        -:   32:    }
    #####:   33:    if (data < root->data) { // If data is less than the current node's data
branch  0 never executed
branch  1 never executed
    #####:   34:        root->left = insert(root->left, data); // Recursively insert into the left subtree
call    0 never executed
    #####:   35:    } else if (data > root->data) { // If data is greater than the current node's data
branch  0 never executed
branch  1 never executed
    #####:   36:        root->right = insert(root->right, data); // Recursively insert into the right subtree
call    0 never executed
        -:   37:    }
    #####:   38:    return root; // Return the modified root
        -:   39:}
        -:   40:
        -:   41:// Function to find the node with the minimum value in the tree
        -:   42:// Used to secure: Proper deletion of a node
function minValueNode called 0 returned 0% blocks executed 0%
    #####:   43:struct Node* minValueNode(struct Node* node) {
    #####:   44:    struct Node* current = node; // Initialize current node as the given node
    #####:   45:    while (current && current->left != NULL) { // Traverse to the leftmost node
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   46:        current = current->left; // Move to the left child
        -:   47:    }
    #####:   48:    return current; // Return the leftmost node
        -:   49:}
        -:   50:
        -:   51:// Function to delete a node with the given key from the binary search tree
        -:   52:// Used to secure: Proper deletion of a node and memory deallocation
function deleteNode called 0 returned 0% blocks executed 0%
    #####:   53:struct Node* deleteNode(struct Node* root, int key) {
    #####:   54:    if (root == NULL) { // If the tree is empty
branch  0 never executed
branch  1 never executed
    #####:   55:        return root; // Return NULL
        -:   56:    }
    #####:   57:    if (key < root->data) { // If the key is less than the current node's data
branch  0 never executed
branch  1 never executed
    #####:   58:        root->left = deleteNode(root->left, key); // Recursively delete from the left subtree
call    0 never executed
    #####:   59:    } else if (key > root->data) { // If the key is greater than the current node's data
branch  0 never executed
branch  1 never executed
    #####:   60:        root->right = deleteNode(root->right, key); // Recursively delete from the right subtree
call    0 never executed
        -:   61:    } else { // If the key is found
    #####:   62:        if (root->left == NULL) { // If the node has no left child
branch  0 never executed
branch  1 never executed
    #####:   63:            struct Node* temp = root->right; // Store the right child
    #####:   64:            free(root); // Free memory allocated for the node
    #####:   65:            return temp; // Return the right child as the new root
    #####:   66:        } else if (root->right == NULL) { // If the node has no right child
branch  0 never executed
branch  1 never executed
    #####:   67:            struct Node* temp = root->left; // Store the left child
    #####:   68:            free(root); // Free memory allocated for the node
    #####:   69:            return temp; // Return the left child as the new root
        -:   70:        }
    #####:   71:        struct Node* temp = minValueNode(root->right); // Find the inorder successor
call    0 never executed
    #####:   72:        root->data = temp->data; // Copy the inorder successor's data to this node
    #####:   73:        root->right = deleteNode(root->right, temp->data); // Delete the inorder successor
call    0 never executed
        -:   74:    }
    #####:   75:    return root; // Return the modified root
        -:   76:}
        -:   77:
        -:   78:// Function to search for a value in the binary search tree
        -:   79:// Used to secure: Proper search operation
function search called 0 returned 0% blocks executed 0%
    #####:   80:struct Node* search(struct Node* root, int key) {
    #####:   81:    if (root == NULL || root->data == key) { // If the tree is empty or the key is found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   82:        return root; // Return the current node
        -:   83:    }
    #####:   84:    if (root->data < key) { // If the key is greater than the current node's data
branch  0 never executed
branch  1 never executed
    #####:   85:        return search(root->right, key); // Search in the right subtree
call    0 never executed
        -:   86:    }
    #####:   87:    return search(root->left, key); // Search in the left subtree
call    0 never executed
        -:   88:}
        -:   89:
        -:   90:// Function to perform in-order traversal of the binary search tree
function inorderTraversal called 0 returned 0% blocks executed 0%
    #####:   91:void inorderTraversal(struct Node* root) {
    #####:   92:    if (root != NULL) { // If the current node is not NULL
branch  0 never executed
branch  1 never executed
    #####:   93:        inorderTraversal(root->left); // Recursively traverse the left subtree
call    0 never executed
    #####:   94:        printf("%d ", root->data); // Print the current node's data
call    0 never executed
    #####:   95:        inorderTraversal(root->right); // Recursively traverse the right subtree
call    0 never executed
        -:   96:    }
    #####:   97:}
        -:   98:
        -:   99:// Function to perform pre-order traversal of the binary search tree
function preorderTraversal called 0 returned 0% blocks executed 0%
    #####:  100:void preorderTraversal(struct Node* root) {
    #####:  101:    if (root != NULL) { // If the current node is not NULL
branch  0 never executed
branch  1 never executed
    #####:  102:        printf("%d ", root->data); // Print the current node's data
call    0 never executed
    #####:  103:        preorderTraversal(root->left); // Recursively traverse the left subtree
call    0 never executed
    #####:  104:        preorderTraversal(root->right); // Recursively traverse the right subtree
call    0 never executed
        -:  105:    }
    #####:  106:}
        -:  107:
        -:  108:// Function to perform post-order traversal of the binary search tree
function postorderTraversal called 0 returned 0% blocks executed 0%
    #####:  109:void postorderTraversal(struct Node* root) {
    #####:  110:    if (root != NULL) { // If the current node is not NULL
branch  0 never executed
branch  1 never executed
    #####:  111:        postorderTraversal(root->left); // Recursively traverse the left subtree
call    0 never executed
    #####:  112:        postorderTraversal(root->right); // Recursively traverse the right subtree
call    0 never executed
    #####:  113:        printf("%d ", root->data); // Print the current node's data
call    0 never executed
        -:  114:    }
    #####:  115:}
        -:  116:
        -:  117:// Function to check if the binary tree is a binary search tree (BST)
        -:  118:// Used to secure: Verification if the tree is BST
function isBSTUtil called 0 returned 0% blocks executed 0%
    #####:  119:int isBSTUtil(struct Node* root, int min, int max) {
    #####:  120:    if (root == NULL) { // If the current node is NULL
branch  0 never executed
branch  1 never executed
    #####:  121:        return 1; // Return true
        -:  122:    }
    #####:  123:    if (root->data < min || root->data > max) { // If the current node's data is out of range
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  124:        return 0; // Return false
        -:  125:    }
    #####:  126:    return isBSTUtil(root->left, min, root->data - 1) && isBSTUtil(root->right, root->data + 1, max); // Recursively check left and right subtrees
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  127:}
        -:  128:
        -:  129:// Function to check if the binary tree is a binary search tree (BST)
function isBST called 0 returned 0% blocks executed 0%
    #####:  130:int isBST(struct Node* root) {
    #####:  131:    return isBSTUtil(root, INT_MIN, INT_MAX); // Check if the tree is a BST within the specified range
call    0 never executed
        -:  132:}
        -:  133:
        -:  134:// Function to calculate the height of the binary tree
function height called 0 returned 0% blocks executed 0%
    #####:  135:int height(struct Node* root) {
    #####:  136:    if (root == NULL) { // If the current node is NULL
branch  0 never executed
branch  1 never executed
    #####:  137:        return 0; // Return 0
        -:  138:    }
    #####:  139:    int leftHeight = height(root->left); // Calculate height of the left subtree
call    0 never executed
    #####:  140:    int rightHeight = height(root->right); // Calculate height of the right subtree
call    0 never executed
    #####:  141:    return (leftHeight > rightHeight) ? (leftHeight + 1) : (rightHeight + 1); // Return the maximum height
branch  0 never executed
branch  1 never executed
        -:  142:}
        -:  143:
        -:  144:// Function to find the minimum value in the binary search tree
function minValue called 0 returned 0% blocks executed 0%
    #####:  145:int minValue(struct Node* root) {
    #####:  146:    struct Node* current = root; // Start from the root node
    #####:  147:    while (current->left != NULL) { // Traverse to the leftmost node
branch  0 never executed
branch  1 never executed
    #####:  148:        current = current->left; // Move to the left child
        -:  149:    }
    #####:  150:    return current->data; // Return the data of the leftmost node
        -:  151:}
        -:  152:
        -:  153:// Function to find the maximum value in the binary search tree
function maxValue called 0 returned 0% blocks executed 0%
    #####:  154:int maxValue(struct Node* root) {
    #####:  155:    struct Node* current = root; // Start from the root node
    #####:  156:    while (current->right != NULL) { // Traverse to the rightmost node
branch  0 never executed
branch  1 never executed
    #####:  157:        current = current->right; // Move to the right child
        -:  158:    }
    #####:  159:    return current->data; // Return the data of the rightmost node
        -:  160:}
