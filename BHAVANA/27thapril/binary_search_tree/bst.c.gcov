        -:    0:Source:bst.c
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include "bst.h" // Include the header file for BST function declarations
        -:    4:
        -:    5:// Function to create a new node
function createNode called 7 returned 100% blocks executed 60%
        7:    6:struct node* createNode(int data) {
        7:    7:    struct node* newNode = (struct node*)malloc(sizeof(struct node)); // Allocate memory for a new node
        7:    8:    if (newNode == NULL) { // Check if memory allocation failed
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:    9:        printf("Memory allocation failed\n");
call    0 never executed
    #####:   10:	free(newNode);
    #####:   11:	exit(1);
call    0 never executed
        -:   12:    }
        7:   13:    newNode->data = data; // Initialize the data field of the new node
        7:   14:    newNode->left = NULL; // Initialize the left child pointer of the new node to NULL
        7:   15:    newNode->right = NULL; // Initialize the right child pointer of the new node to NULL
        7:   16:    return newNode; // Return the newly created node
        -:   17:}
        -:   18:
        -:   19:// Function to insert a new node into the BST
function insert called 17 returned 100% blocks executed 100%
       17:   20:struct node* insert(struct node* root, int data) {
       17:   21:    if (root == NULL) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        7:   22:        return createNode(data); // If the tree is empty, create a new node as the root
call    0 returned 100%
        -:   23:    }
       10:   24:    if (data < root->data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:   25:        root->left = insert(root->left, data); // If data is less than the root, insert into the left subtree
call    0 returned 100%
        5:   26:    } else if (data > root->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:   27:        root->right = insert(root->right, data); // If data is greater than the root, insert into the right subtree
call    0 returned 100%
        -:   28:    }
       10:   29:    return root; // Return the root of the updated tree
        -:   30:}
        -:   31:
        -:   32:// Function to search for a node with a given data
function search called 2 returned 100% blocks executed 70%
        2:   33:int search(struct node* root, int data) {
        2:   34:    if (root == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   35:        return 0; // If the tree is empty, return 0 (not found)
        -:   36:    }
        2:   37:    if (root->data == data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:   38:        return 1; // If the root node contains the data, return 1 (found)
        1:   39:    } else if (data < root->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   40:        return search(root->left, data); // Search in the left subtree
call    0 returned 100%
        -:   41:    } else {
    #####:   42:        return search(root->right, data); // Search in the right subtree
call    0 never executed
        -:   43:    }
        -:   44:}
        -:   45:
        -:   46:// Function to perform an in-order traversal of the BST
function inorderTraversal called 28 returned 100% blocks executed 100%
       28:   47:void inorderTraversal(struct node* root) {
       28:   48:    if (root != NULL) {
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
       13:   49:        inorderTraversal(root->left); // Traverse the left subtree
call    0 returned 100%
       13:   50:        printf("%d ", root->data); // Print the data of the root node
call    0 returned 100%
       13:   51:        inorderTraversal(root->right); // Traverse the right subtree
call    0 returned 100%
        -:   52:    }
       28:   53:}
        -:   54:
        -:   55:// Function to find the minimum value in the BST
function findMin called 1 returned 100% blocks executed 75%
        1:   56:int findMin(struct node* root) {
        1:   57:    if (root == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   58:        printf("BST is empty\n");
call    0 never executed
    #####:   59:        exit(1);
call    0 never executed
        -:   60:    }
        3:   61:    while (root->left != NULL) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:   62:        root = root->left;
        -:   63:    }
        1:   64:    return root->data;
        -:   65:}
        -:   66:
        -:   67:// Function to find the maximum value in the BST
function findMax called 1 returned 100% blocks executed 75%
        1:   68:int findMax(struct node* root) {
        1:   69:    if (root == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   70:        printf("BST is empty\n");
call    0 never executed
    #####:   71:        exit(1);
call    0 never executed
        -:   72:    }
        3:   73:    while (root->right != NULL) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:   74:        root = root->right;
        -:   75:    }
        1:   76:    return root->data;
        -:   77:}
        -:   78:
        -:   79:// Function to delete a node from the BST
function deleteNode called 3 returned 100% blocks executed 76%
        3:   80:struct node* deleteNode(struct node* root, int data) {
        3:   81:    if (root == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   82:        return root;
        -:   83:    }
        3:   84:    if (data < root->data) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:   85:        root->left = deleteNode(root->left, data);
call    0 returned 100%
        2:   86:    } else if (data > root->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   87:        root->right = deleteNode(root->right, data);
call    0 never executed
        -:   88:    } else {
        2:   89:        if (root->left == NULL) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:   90:            struct node* temp = root->right;
        1:   91:            free(root);
        1:   92:            return temp;
        1:   93:        } else if (root->right == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   94:            struct node* temp = root->left;
    #####:   95:            free(root);
    #####:   96:            return temp;
        -:   97:        }
        1:   98:        struct node* temp = minValueNode(root->right);
call    0 returned 100%
        1:   99:        root->data = temp->data;
        1:  100:        root->right = deleteNode(root->right, temp->data);
call    0 returned 100%
        -:  101:    }
        2:  102:    return root;
        -:  103:}
        -:  104:
        -:  105:// Function to find the inorder successor (smallest in the right subtree)
function minValueNode called 1 returned 100% blocks executed 83%
        1:  106:struct node* minValueNode(struct node* node) {
        1:  107:    struct node* current = node;
        1:  108:    while (current && current->left != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
    #####:  109:        current = current->left;
        -:  110:    }
        1:  111:    return current;
        -:  112:}
        -:  113:
        -:  114:// Function to calculate the height of the BST
function height called 15 returned 100% blocks executed 100%
       15:  115:int height(struct node* root) {
       15:  116:    if (root == NULL) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        8:  117:        return -1;
        -:  118:    }
        7:  119:    int leftHeight = height(root->left);
call    0 returned 100%
        7:  120:    int rightHeight = height(root->right);
call    0 returned 100%
        7:  121:    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
        -:  122:}
