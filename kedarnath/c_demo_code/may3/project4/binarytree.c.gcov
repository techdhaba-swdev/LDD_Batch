        -:    0:Source:binarytree.c
        -:    1:#include"binarytree.h"
        -:    2:
        -:    3:struct Node {
        -:    4:    int data;
        -:    5:    struct Node* left;
        -:    6:    struct Node* right;
        -:    7:} ;
        -:    8:
        -:    9:// Function to create a new node
        7:   10:Node* createNode(int data) {
        7:   11:    Node* newNode = (Node*)malloc(sizeof(Node));
        7:   12:    if (newNode == NULL) {
    #####:   13:        printf("Memory allocation failed\n");
    #####:   14:        exit(EXIT_FAILURE);
        -:   15:    }
        7:   16:    newNode->data = data;
        7:   17:    newNode->left = NULL;
        7:   18:    newNode->right = NULL;
        7:   19:    return newNode;
        -:   20:}
        -:   21:
        -:   22:// Function to insert a node into BST
       17:   23:Node* insert(Node* root, int data) {
       17:   24:    if (root == NULL) {
        7:   25:        return createNode(data);
        -:   26:    }
       10:   27:    if (data < root->data) {
        5:   28:        root->left = insert(root->left, data);
        5:   29:    } else if (data > root->data) {
        5:   30:        root->right = insert(root->right, data);
        -:   31:    }
       10:   32:    return root;
        -:   33:}
        -:   34:
        -:   35:// Function to delete a node from BST
        3:   36:Node* delete(Node* root, int data) {
        3:   37:    if (root == NULL) {
    #####:   38:        return root;
        -:   39:    }
        3:   40:    if (data < root->data) {
        2:   41:        root->left = delete(root->left, data);
        1:   42:    } else if (data > root->data) {
    #####:   43:        root->right = delete(root->right, data);
        -:   44:    } else {
        -:   45:        // Node with only one child or no child
        1:   46:        if (root->left == NULL) {
        1:   47:            Node* temp = root->right;
        1:   48:            free(root);
        1:   49:            return temp;
    #####:   50:        } else if (root->right == NULL) {
    #####:   51:            Node* temp = root->left;
    #####:   52:            free(root);
    #####:   53:            return temp;
        -:   54:        }
        -:   55:        // Node with two children: Get the inorder successor (smallest in the right subtree)
    #####:   56:        Node* temp = minValueNode(root->right);
        -:   57:        // Copy the inorder successor's content to this node
    #####:   58:        root->data = temp->data;
        -:   59:        // Delete the inorder successor
    #####:   60:        root->right = delete(root->right, temp->data);
        -:   61:    }
        2:   62:    return root;
        -:   63:}
        -:   64:
        -:   65:// Function to find the node with the minimum value
    #####:   66:Node* minValueNode(Node* node) {
    #####:   67:    Node* current = node;
    #####:   68:    while (current && current->left != NULL) {
    #####:   69:        current = current->left;
        -:   70:    }
    #####:   71:    return current;
        -:   72:}
        -:   73:
        -:   74:// Function to search for a node in BST
        2:   75:Node* search(Node* root, int data) {
        2:   76:    if (root == NULL || root->data == data) {
        1:   77:        return root;
        -:   78:    }
        1:   79:    if (data < root->data) {
        1:   80:        return search(root->left, data);
        -:   81:    }
    #####:   82:    return search(root->right, data);
        -:   83:}
        -:   84:
        -:   85:// Function to perform in-order traversal (left, root, right)
       28:   86:void inOrderTraversal(Node* root) {
       28:   87:    if (root != NULL) {
       13:   88:        inOrderTraversal(root->left);
       13:   89:        printf("%d ", root->data);
       13:   90:        inOrderTraversal(root->right);
        -:   91:    }
       28:   92:}
        -:   93:
        -:   94:// Function to perform pre-order traversal (root, left, right)
       15:   95:void preOrderTraversal(Node* root) {
       15:   96:    if (root != NULL) {
        7:   97:        printf("%d ", root->data);
        7:   98:        preOrderTraversal(root->left);
        7:   99:        preOrderTraversal(root->right);
        -:  100:    }
       15:  101:}
        -:  102:
        -:  103:// Function to perform post-order traversal (left, right, root)
       15:  104:void postOrderTraversal(Node* root) {
       15:  105:    if (root != NULL) {
        7:  106:        postOrderTraversal(root->left);
        7:  107:        postOrderTraversal(root->right);
        7:  108:        printf("%d ", root->data);
        -:  109:    }
       15:  110:}
        -:  111:
        -:  112:// Function to check if a binary tree is a binary search tree (BST)
       15:  113:bool isBSTUtil(Node* root, int min, int max) {
       15:  114:    if (root == NULL) {
        8:  115:        return true;
        -:  116:    }
        7:  117:    if (root->data < min || root->data > max) {
    #####:  118:        return false;
        -:  119:    }
      14*:  120:    return isBSTUtil(root->left, min, root->data - 1) &&
        7:  121:           isBSTUtil(root->right, root->data + 1, max);
        -:  122:}
        -:  123:
        1:  124:bool isBST(Node* root) {
        1:  125:    return isBSTUtil(root, INT_MIN, INT_MAX);
        -:  126:}
        -:  127:
        -:  128:// Function to find the height of a binary tree
       15:  129:int height(Node* root) {
       15:  130:    if (root == NULL) {
        8:  131:        return 0;
        -:  132:    }
        7:  133:    int leftHeight = height(root->left);
        7:  134:    int rightHeight = height(root->right);
       7*:  135:    return (leftHeight > rightHeight) ? leftHeight + 1 : rightHeight + 1;
        -:  136:}
        -:  137:
        -:  138:// Function to find the minimum and maximum values in a binary tree
       15:  139:void findMinMax(Node* root, int* min, int* max) {
       15:  140:    if (root == NULL) {
        8:  141:        return;
        -:  142:    }
        7:  143:    if (root->data < *min) {
    #####:  144:        *min = root->data;
        -:  145:    }
        7:  146:    if (root->data > *max) {
        3:  147:        *max = root->data;
        -:  148:    }
        7:  149:    findMinMax(root->left, min, max);
        7:  150:    findMinMax(root->right, min, max);
        -:  151:}
        -:  152:
        -:  153:
