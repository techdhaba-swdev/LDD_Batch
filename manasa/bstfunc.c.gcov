        -:    0:Source:bstfunc.c
        -:    1:#include "bstfunc.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <limits.h>
        -:    5:
function createNode called 8 returned 100% blocks executed 60%
        8:    6:TreeNode* createNode(int data) {
        8:    7:    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
        8:    8:    if (newNode == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:    9:        printf("Memory allocation failed.\n");
call    0 never executed
    #####:   10:        exit(EXIT_FAILURE);
call    0 never executed
        -:   11:    }
        8:   12:    newNode->data = data;
        8:   13:    newNode->left = NULL;
        8:   14:    newNode->right = NULL;
        8:   15:    return newNode;
        -:   16:}
        -:   17:
function insert called 21 returned 100% blocks executed 100%
       21:   18:TreeNode* insert(TreeNode* root, int data) {
       21:   19:    if (root == NULL)
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        8:   20:        return createNode(data);
call    0 returned 100%
       13:   21:    if (data < root->data)
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        5:   22:        root->left = insert(root->left, data);
call    0 returned 100%
        8:   23:    else if (data > root->data)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:   24:        root->right = insert(root->right, data);
call    0 returned 100%
       13:   25:    return root;
        -:   26:}
        -:   27:
function minValueNode called 0 returned 0% blocks executed 0%
    #####:   28:TreeNode* minValueNode(TreeNode* node) {
    #####:   29:    TreeNode* current = node;
    #####:   30:    while (current && current->left != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   31:        current = current->left;
    #####:   32:    return current;
        -:   33:}
        -:   34:
function deleteNode called 3 returned 100% blocks executed 65%
        3:   35:TreeNode* deleteNode(TreeNode* root, int key) {
        3:   36:    if (root == NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   37:        return root;
        3:   38:    if (key < root->data)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:   39:        root->left = deleteNode(root->left, key);
call    0 returned 100%
        2:   40:    else if (key > root->data)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:   41:        root->right = deleteNode(root->right, key);
call    0 returned 100%
        -:   42:    else {
        1:   43:        if (root->left == NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   44:            TreeNode* temp = root->right;
        1:   45:            free(root);
        1:   46:            return temp;
        -:   47:        }
    #####:   48:        else if (root->right == NULL) {
branch  0 never executed
branch  1 never executed
    #####:   49:            TreeNode* temp = root->left;
    #####:   50:            free(root);
    #####:   51:            return temp;
        -:   52:        }
    #####:   53:        TreeNode* temp = minValueNode(root->right);
call    0 never executed
    #####:   54:        root->data = temp->data;
    #####:   55:        root->right = deleteNode(root->right, temp->data);
call    0 never executed
        -:   56:    }
        2:   57:    return root;
        -:   58:}
        -:   59:
function search called 3 returned 100% blocks executed 100%
        3:   60:TreeNode* search(TreeNode* root, int key) {
        3:   61:    if (root == NULL || root->data == key)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
        1:   62:        return root;
        2:   63:    if (root->data < key)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:   64:        return search(root->right, key);
call    0 returned 100%
        1:   65:    return search(root->left, key);
call    0 returned 100%
        -:   66:}
        -:   67:
function inorderTraversal called 15 returned 100% blocks executed 100%
       15:   68:void inorderTraversal(TreeNode* root) {
       15:   69:    if (root != NULL) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7:   70:        inorderTraversal(root->left);
call    0 returned 100%
        7:   71:        printf("%d ", root->data);
call    0 returned 100%
        7:   72:        inorderTraversal(root->right);
call    0 returned 100%
        -:   73:    }
       15:   74:}
        -:   75:
function preorderTraversal called 15 returned 100% blocks executed 100%
       15:   76:void preorderTraversal(TreeNode* root) {
       15:   77:    if (root != NULL) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7:   78:        printf("%d ", root->data);
call    0 returned 100%
        7:   79:        preorderTraversal(root->left);
call    0 returned 100%
        7:   80:        preorderTraversal(root->right);
call    0 returned 100%
        -:   81:    }
       15:   82:}
        -:   83:
function postorderTraversal called 15 returned 100% blocks executed 100%
       15:   84:void postorderTraversal(TreeNode* root) {
       15:   85:    if (root != NULL) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7:   86:        postorderTraversal(root->left);
call    0 returned 100%
        7:   87:        postorderTraversal(root->right);
call    0 returned 100%
        7:   88:        printf("%d ", root->data);
call    0 returned 100%
        -:   89:    }
       15:   90:}
        -:   91:
function isBSTUtil called 15 returned 100% blocks executed 85%
       15:   92:int isBSTUtil(TreeNode* root, int min_val, int max_val) {
       15:   93:    if (root == NULL) 
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        8:   94:        return 1;
        7:   95:    if (root->data < min_val || root->data > max_val)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   96:        return 0;
       7*:   97:    return isBSTUtil(root->left, min_val, root->data - 1) && isBSTUtil(root->right, root->data + 1, max_val);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:   98:}
        -:   99:
function isBST called 1 returned 100% blocks executed 100%
        1:  100:int isBST(TreeNode* root) {
        1:  101:    return isBSTUtil(root, INT_MIN, INT_MAX);
call    0 returned 100%
        -:  102:}
        -:  103:
function max called 7 returned 100% blocks executed 100%
        7:  104:int max(int a, int b) {
        7:  105:    return (a > b) ? a : b;
        -:  106:}
        -:  107:
function findHeight called 15 returned 100% blocks executed 100%
       15:  108:int findHeight(TreeNode* root) {
       15:  109:    if (root == NULL)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        8:  110:        return 0;
        7:  111:    int leftHeight = findHeight(root->left);
call    0 returned 100%
        7:  112:    int rightHeight = findHeight(root->right);
call    0 returned 100%
        7:  113:    return 1 + max(leftHeight, rightHeight);
call    0 returned 100%
        -:  114:}
        -:  115:
function findMinMax called 15 returned 100% blocks executed 100%
       15:  116:void findMinMax(TreeNode* root, int* min, int* max) {
       15:  117:    if (root == NULL)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        8:  118:        return;
        7:  119:    if (root->data < *min)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
        3:  120:        *min = root->data;
        7:  121:    if (root->data > *max)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        4:  122:        *max = root->data;
        7:  123:    findMinMax(root->left, min, max);
call    0 returned 100%
        7:  124:    findMinMax(root->right, min, max);
call    0 returned 100%
        -:  125:}
