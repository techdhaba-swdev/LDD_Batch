        -:    0:Source:quicksort.c
        -:    1:#include "quicksort.h"
        -:    2:
        -:    3:// Function definition for partitioning the array
function partition called 7 returned 100% blocks executed 100%
        7:    4:int partition(int arr[], int low, int high) {
        7:    5:    int pivot = arr[high]; // Choose the rightmost element as pivot
        7:    6:    int i = low - 1; // Index of smaller element
       40:    7:    for (int j = low; j < high; j++) { // Loop through the array
branch  0 taken 82%
branch  1 taken 18% (fallthrough)
       33:    8:        if (arr[j] < pivot) { // If current element is smaller than the pivot
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
       10:    9:            i++; // Increment index of smaller element
        -:   10:            // Swap arr[i] and arr[j]
       10:   11:            int temp = arr[i];
       10:   12:            arr[i] = arr[j];
       10:   13:            arr[j] = temp;
        -:   14:        }
        -:   15:    }
        -:   16:    // Swap arr[i + 1] and arr[high] (pivot)
        7:   17:    int temp = arr[i + 1];
        7:   18:    arr[i + 1] = arr[high];
        7:   19:    arr[high] = temp;
        7:   20:    return i + 1; // Return the partitioning index
        -:   21:}
        -:   22:
        -:   23:// Function definition for recursive quicksort
function quicksort called 15 returned 100% blocks executed 100%
       15:   24:void quicksort(int arr[], int low, int high) {
       15:   25:	 if (low < high) { // If there are more than one element in the subarray
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7:   26:        int pi = partition(arr, low, high); // Partition the array
call    0 returned 100%
        7:   27:        quicksort(arr, low, pi - 1); // Recursively sort elements before partition
call    0 returned 100%
        7:   28:        quicksort(arr, pi + 1, high); // Recursively sort elements after partition
call    0 returned 100%
        -:   29:    }
       15:   30:}
