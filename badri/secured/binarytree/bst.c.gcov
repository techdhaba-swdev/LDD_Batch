        -:    0:Source:bst.c
        -:    1:#include "bst.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h> // Added for error handling
        -:    4:
        -:    5:// Function to insert a new node into the tree while maintaining the BST property
function insert called 17 returned 100% blocks executed 100%
       17:    6:struct node* insert(struct node* root, int data) {
       17:    7:    if (root == NULL) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -:    8:        // If tree is empty, create a new node and return it as the new root
        7:    9:        return createNode(data);
call    0 returned 100%
        -:   10:    }
       10:   11:    if (data < root->data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   12:        // If data is less than current node's data, recursively insert into left subtree
        5:   13:        root->left = insert(root->left, data);
call    0 returned 100%
        5:   14:    } else if (data > root->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   15:        // If data is greater than current node's data, recursively insert into right subtree
        5:   16:        root->right = insert(root->right, data);
call    0 returned 100%
        -:   17:    }
        -:   18:    // If data is equal to current node's data, do nothing (BST doesn't allow duplicates)
       10:   19:    return root;
        -:   20:}
        -:   21:
        -:   22:// Function to search for a node with the given data in the tree
function search called 3 returned 100% blocks executed 90%
        3:   23:int search(struct node* root, int data) {
        3:   24:    if (root == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   25:        // If tree is empty or node not found, return 0
    #####:   26:        return 0;
        -:   27:    }
        3:   28:    if (root->data == data) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:   29:        // If current node's data matches the search data, return 1
        1:   30:        return 1;
        2:   31:    } else if (data < root->data) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:   32:        // If search data is less than current node's data, search in left subtree
        1:   33:        return search(root->left, data);
call    0 returned 100%
        -:   34:    } else {
        -:   35:        // If search data is greater than current node's data, search in right subtree
        1:   36:        return search(root->right, data);
call    0 returned 100%
        -:   37:    }
        -:   38:}
        -:   39:
        -:   40:// Function to perform an in-order traversal of the tree (prints node values)
function inorderTraversal called 15 returned 100% blocks executed 100%
       15:   41:void inorderTraversal(struct node* root) {
       15:   42:    if (root != NULL) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        -:   43:        // Traverse left subtree
        7:   44:        inorderTraversal(root->left);
call    0 returned 100%
        -:   45:        // Print current node's data
        7:   46:        printf("%d ", root->data);
call    0 returned 100%
        -:   47:        // Traverse right subtree
        7:   48:        inorderTraversal(root->right);
call    0 returned 100%
        -:   49:    }
       15:   50:}
