        -:    0:Source:bst.c
        -:    1:#include "bst.h"
        -:    2:#include<stdio.h>
        -:    3:#include<stdlib.h>
        -:    4:
        -:    5:// Function to create a new node
        7:    6:struct node* createNode(int data) {
        7:    7:    struct node* newNode = (struct node*)malloc(sizeof(struct node));
        7:    8:    if (newNode != NULL) { //check if memory allocation was successful
        7:    9:        newNode->data = data;//initialize node data
        7:   10:        newNode->left = NULL;
        7:   11:        newNode->right = NULL;
        -:   12:    }
        7:   13:    return newNode;
        -:   14:}
        -:   15:
        -:   16:// Function to insert a new node into the BST
       17:   17:struct node* insert(struct node* root, int data) {
       17:   18:    if (root == NULL) { //if tree is empty create a new node and return
        7:   19:        return createNode(data);
        -:   20:    }
        -:   21:
       10:   22:    if (data < root->data) {  //insert into left subtree if data is less than current node
        5:   23:        root->left = insert(root->left, data);
        5:   24:    } else if (data > root->data) { //insert into right subtree if data is greater than current nod
        5:   25:        root->right = insert(root->right, data);
        -:   26:    }
        -:   27:
       10:   28:    return root;
        -:   29:}
        -:   30:
        -:   31:// Function to search for a node with the given data in the BST
        1:   32:int search(struct node* root, int data) {
        1:   33:    if (root == NULL || root->data) { //if tree is empty or node with data is found return 
        1:   34:        return root != NULL; //retun 1 if root is not null , 0 otherwise
        -:   35:    }
        -:   36:
    #####:   37:    if (data < root ->data) { //search left subtree if data is less than current nodes data
    #####:   38:        return search(root->left,data);
        -:   39:
        -:   40:    }
        -:   41:    else  {
    #####:   42:        return search(root->right, data);
        -:   43:    }
        -:   44:}
        -:   45:
        -:   46:// Function to perform an in-order traversal of the BST
       15:   47:void inorderTraversal(struct node* root) {
       15:   48:    if (root == NULL) {//if tree is empty return 
        8:   49:	    return;
        -:   50:    }
        7:   51:        inorderTraversal(root->left);//transvers left tree
        7:   52:        printf("%d ", root->data);
        7:   53:        inorderTraversal(root->right);//transverse right tree
        -:   54:    }
        -:   55:
