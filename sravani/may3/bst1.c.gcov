        -:    0:Source:bst1.c
        -:    1:#include "bst1.h"
        -:    2:#include<stdio.h>
        -:    3:#include<stdlib.h>
        -:    4:
        -:    5:// Function to create a new node
        7:    6:struct node* createNode(int data) {
        7:    7:    struct node* newNode = (struct node*)malloc(sizeof(struct node));
        7:    8:    if (newNode != NULL) { //check if memory allocation was successful
        7:    9:        newNode->data = data;//initialize node data
        7:   10:        newNode->left = NULL;
        7:   11:        newNode->right = NULL;
        -:   12:    }
        7:   13:    return newNode;
        -:   14:}
        -:   15:
        -:   16:
        -:   17:// Function to insert a new node into the BST
       17:   18:struct node* insert(struct node* root, int data) {
       17:   19:    if (root == NULL) { //if tree is empty create a new node and return
        7:   20:        return createNode(data);
        -:   21:    }
        -:   22:
       10:   23:    if (data < root->data) {  //insert into left subtree if data is less than current node
        5:   24:        root->left = insert(root->left, data);
        5:   25:    } else if (data > root->data) { //insert into right subtree if data is greater than current nod
        5:   26:        root->right = insert(root->right, data);
        -:   27:    }
        -:   28:
       10:   29:    return root;
        -:   30:}
        -:   31:
        -:   32://Function to find the node with the minimum value in a subtree
    #####:   33:struct node* minValueNode(struct node* node){
    #####:   34:	struct node* current = node;
    #####:   35:	while(current && current ->left != NULL){
    #####:   36:		current = current ->left;
        -:   37:	}
    #####:   38:	return current;
        -:   39:}
        -:   40:// Function to delete for a node with the given data in the BST
        3:   41:struct node* deleteNode(struct node* root, int data){
        3:   42:	if(root == NULL){
    #####:   43:		return root;
        -:   44:	}
        3:   45:	if(data < root -> data){
        2:   46:		root->left=deleteNode(root->left,data);
        -:   47:	}
        1:   48:	else if(data > root->data){
    #####:   49:		root->right=deleteNode(root->right,data);
        -:   50:	}
        -:   51:	else {
        1:   52:		if(root->left == NULL){
        1:   53:			struct node* temp = root->right;
        1:   54:			free(root);
        1:   55:			return temp;
        -:   56:		}
    #####:   57:		else if(root->right == NULL)
        -:   58:		{
    #####:   59:			struct node* temp = root->left;
    #####:   60:			free(root);
    #####:   61:			return temp;
        -:   62:	}
    #####:   63:	struct node* temp = minValueNode(root->right);
    #####:   64:	root->data = temp->data;
    #####:   65:	root->right=deleteNode(root->right,temp->data);
        -:   66:	}
        2:   67:	return root;
        -:   68:}
        -:   69:
        -:   70:// Function to search for a node with the given data in the BST
        1:   71:int search(struct node* root, int data) {
        1:   72:    if (root == NULL || root->data) { //if tree is empty or node with data is found return
        1:   73:        return root != NULL; //retun 1 if root is not null , 0 otherwise
        -:   74:    }
        -:   75:
    #####:   76:    if (data < root ->data) { //search left subtree if data is less than current nodes data
    #####:   77:        return search(root->left,data);
        -:   78:
        -:   79:    }
        -:   80:    else  {
    #####:   81:        return search(root->right, data);
        -:   82:    }
        -:   83:}
        -:   84:
        -:   85:// Function to perform an in-order traversal of the BST
       15:   86:void inorderTraversal(struct node* root) {
       15:   87:    if (root == NULL) {//if tree is empty return
        8:   88:	    return;
        -:   89:    }
        7:   90:        inorderTraversal(root->left);//transvers left tree
        7:   91:        printf("%d ", root->data);
        7:   92:        inorderTraversal(root->right);//transverse right tree
        -:   93:    }
        -:   94:
